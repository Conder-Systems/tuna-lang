globals := {value={varDecl | func} {ws+ | '$'}}*

mutable := 'let'
constant := 'const'
varDecl := ws* mutability={ constant | mutable } ws+ name=name ws* equals ws* value=expression
name := name='[a-zA-Z]+\w*'
equals := '='
ws := '\s'
obj := '\{' ws* fields=fields ws* '\}'
str := '\'' value='[\w \t]*' '\''
bool := value={'true' | 'false'}
num := value='-?\d+(\.\d+)?'
literal := obj | str | bool | num
newLineOrComma := '\n|,'
field := name=name ws* ':' value=literal newLineOrComma?
fields := value=field*
space := ' '

scopedExecution := ws* '\{' body=executable '\}'
executable := ws* value={value={ret | varDecl | forLoop | ifs | assignment | functionCall | expression } ws+ }*
expression :=  prefix={prefixOps}? root={literal | name   } methods={method}* infix={sign=infixOps arg=expression}?
method := method={parameterIndex | methodInvoke | literalIndex}

not := 'not' ws+
minus := space* '-' space*
mult := space* '\*' space*
prefixOps := op={not | minus}
plus := space* '\+' space*
infixOps := op={plus | minus | mult}

functionCall := name=name args=args
parameterIndex := '\[' space* value={expression} space* '\]'
literalIndex := '\.' value={name}
methodInvoke := '\.' name=name args=args

forLoop := 'for' space+ rowVar=name space+ 'in' space+ value=expression do=scopedExecution

objectIndex := obj=expression index={parameterIndex | literalIndex}
ret := 'return(?=\s)' space* value={'(?<= )' exp=expression}?
func := ws* 'pub' space+ 'func' space+ name=name space* params=params body=scopedExecution
params := '\(' ws* leadingParams={name=name newLineOrComma ws*}* ws* lastParam={name}? ws* '\)'
args := '\(' ws* leadingArgs={value=expression newLineOrComma ws*}* ws* lastArg={expression}? ws* '\)'
assignment := target=expression space* equals space* value=expression

conditionalExec := cond=expression do=scopedExecution
ifs := 'if' space+ if_this={conditionalExec} elifs={elif}*  otherwise={otherwise}?
elif := ws* 'else' space* 'if' space+ else_this={conditionalExec}
otherwise := ws* 'else' do=scopedExecution