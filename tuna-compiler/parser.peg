globals := {value={varDecl | func} {ws+ | '$'}}*

mutable := 'let'
constant := 'const'
varDecl := ws* mutability={ constant | mutable } ws+ name=name ws* equals ws* value=expression
name := name='[a-zA-Z]+\w*'
equals := '='
ws := '\s'
obj := '\{' ws* fields=fields ws* '\}'
str := '\'' value='[\w \t]*' '\''
bool := value={'true' | 'false'}
num := value='-?\d+(\.\d+)?'
literal := obj | str | bool | num
newLineOrComma := '\n|,'
field := name=name ws* ':' value=literal newLineOrComma?
fields := value=field*
space := ' '

scopedExecution := ws* '\{' body=executable '\}'
executable := ws* value={value={ret | varDecl | forLoop | ifs | assignment | functionCall | expression } ws+ }*
expression := !ret root={literal | name   } methods={method}*
method := method={parameterIndex | funcMethod | literalIndex}

functionCall := name=name args=args
parameterIndex := '\[' space* value={expression} space* '\]'
literalIndex := '\.' value={name}
funcMethod := '\.' name=name args=args

forLoop := 'for' space+ rowVar=name space+ 'in' space+ value=expression do=scopedExecution

objectIndex := obj=expression index={parameterIndex | literalIndex}
ret := 'return(?=\s)' space* value={'(?<= )' exp=expression}?
func := ws* 'pub' space+ 'func' space+ name=name space* params=params body=scopedExecution
params := '\(' ws* leadingParams={name=name newLineOrComma ws*}* ws* lastParam={name}? ws* '\)'
args := '\(' ws* leadingArgs={value=expression newLineOrComma ws*}* ws* lastArg={expression}? ws* '\)'
assignment := target=expression space* equals space* value=expression

ifs := 'if' space+ cond=expression do=scopedExecution  otherwise={otherwise}?
otherwise := ws* 'else' space+ do=scopedExecution